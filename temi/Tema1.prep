1) Опишете как ОС разделят ресурсите на изчислителната система, дайте примери за основните типове разделяне:
а) Разделяне на пространството (памети)
б) Разделяне на времето (процесори, други у-ва)

ОС управлява ресурсите, за чийто достъп различни програми и/или потребители се състезават, и осигурява, че ползвателите на тези ресурси няма да си пречат. Проблемът се състои от това, че различните ресурси имат различни възможност за съвместно ползване (процесор, оперативна памет, входни и изходни устройства и други).

а) ОС разделя ресурсите на части и ги разделя справедливо между процесите и/ли потребителите, които се нуждаят от достъп до тях. ОС следи за свободните и заетите ресурси и осигурява защита.
б) Процесите ползват ресурсите един след друг. ОС се грижи за това да определя кой ще бъде следващия, който ще ползва дадения ресурс, колко дълго ще го използва и може да отнема насилствено ресурса от дадения процес. Това се нарича преразпределение. Възможно е преразпределение върху ресурсите от централния процесор, не е възможно за печатащите устройства например.

2) Опишете с 1-2 изречения работата на следните системни извиквания в стандарта POSIX:

-pipe() -> pipe(int pipefd[2]) - Създава комуникационна тръба за изпращане и получаване на информация между два процеса. Приема като аргумент масив с големина 2 от цели числа, в които се запазват файловите дескриптори на входния и изходния файл на тръбата. pipefd[0] e входният, а pipefd[1] е изходният. Връща 0 при успешно създаване и -1 при грешка, и вдига сигнала на errno със съответната грешка.

-dup2(int oldfd, int newfd) - Затваря ресурса към който е сочил файловият дескриптор newfd и го кара да сочи там, където е сочил oldfd.

-fork() - създава нов процес-дете, който е почти идентичен на родителя си. Детето наследява всички данни и отворени ресурси на родителя и продължава от реда на извикване на функцията. Връща резултат -1 при неуспешно "форк-ване", 0, ако се намираме в процеса-дете и връща pid-то на детето, ако се намираме в процеса-родител.

-exec() - заменя процеса, който изпълнява програмата с друг, при успех не връща нищо, при грешка, връща -1 и се вдига сигнала на errno със съответната грешка.
- execl(const char* path, const char* arg..., 0)
- execv(const char* path, const char* args[]);
- execlp(const char* name, const char* arg..., 0);
- execvp(const char* name, const char* args[]);

- pid_t wait(int* status) - процесът-родител изчаква ПЪРВОТО завършило дете и връща pid-то му. В status се запазва изходния статус на детето.

- pid_t waitpid(pid_t pid, int* status, int options) - процесът-родител изчаква детето, чийто pid съвпада с подадения. В аргумента статус се запазва изходния резултат от изпълнението на процеса-дете. Опциите предоставят възможност за предотвратяване на блокирането на родителя. Връща pid-то на детето.
